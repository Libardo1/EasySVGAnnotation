{
    "contents" : "library(SVGAnnotation)\nlibrary(plyr)\n\n#' EasySVGAnnotation-ready Lattice Boxplot\n#' \n#' This function generates a lattice boxplot with suitable defaults for the\n#' SVG annotation package to parse symbols plotted correctly.\n#' \n#' The key is ensuring the color for \\code{plot.symbol} is different from\n#' \\code{box.rectangle}, \\code{box.umbrella}, and \\code{box.dot}.\n#' \n#' @param ... the call normally supplied to \\code{bwplot}\n#' @seealso \\code{\\link{bwplot}}\n#' @export\nSVG.bwplot <- function( ... ) {\n  bwplot( ...,\n         par.settings = list(\n           box.rectangle = list(col=\"black\"),\n           box.dot = list(col=\"black\"),\n           box.umbrella = list(col=\"black\"),\n           plot.symbol=list(col=\"grey1\")\n           ),\n         fill=\"lavender\"\n         )\n}\n\n## Function to check whether the current lattice plot\n## is / contains boxplots. Works for single and multi-panel\n## boxplots.\n\n#' Check if Current Plot Object is a Boxplot\n#' \n#' This function checks whether the current lattice plot is, or contains,\n#' boxplots. Works for single and multi-panel boxplots.\n#' \n#' @param plot the \\code{lattice} plot object.\nworkingWithBoxPlots <- function( plot ) {\n  if( !is.function( plot$panel ) ) {\n    if( plot$panel == \"panel.bwplot\" ) {\n      return(TRUE)\n    } else {\n      return(FALSE)\n    }\n  } else {\n    tmp <- capture.output( plot$panel )\n    if( length( grep( \"panel\\\\.bwplot\", tmp ) ) > 0 ) {\n      return(TRUE)\n    } else {\n      return(FALSE)\n    }\n  }\n}\n\n#' Rearrange Points within Panel\n#' \n#' The x and y points within a panel are re-arranged so that their order matches\n#' the order \\code{makeSVG} actually plots the points.\n#' \n#' @param plot the \\code{lattice} plot object.\nrearrangePanelXYPoints <- function( plot ) {\n  \n  for( i in 1:length(plot$panel.args) ) {\n    \n    tmp <- as.data.frame( plot$panel.args[[i]] )\n    tmp <- arrange( tmp, x, -y )\n    plot$panel.args[[i]] <- as.list(tmp)\n    \n  }\n  \n  return( plot )\n  \n}\n\n#' Get Names from Data Frame for SVG Annotation\n#' \n#' This function parses a data frame into a format suitable for annotation\n#' of the generated SVG plot.\n#' @param dat the data frame used in generating the lattice plot.\n#' @param x the x variable\n#' @param y the y variable\n#' @param cols the columns to keep\n#' @param round number of decimal points to keep on x and y\nSVG.getNames <- function(dat, x=NULL, y=NULL, cols=NULL, round=3) {\n  \n  if( is.null(x) | is.null(y) ) {\n    stop(\"You must specify 'x', 'y' in the method call.\")\n  }\n  \n  dat <- dat[ !is.na(dat[x]) & !is.na(dat[y]), ]\n  \n  if( !is.null(cols) ) {\n    dat <- dat[,cols]\n  }\n  \n  ## round off the double / decimals\n  dat <- as.data.frame( lapply( dat, function(x) {\n    if( is.numeric(x) ) {\n      round(x, round)\n    } else {\n      x\n    }\n  }) )\n  \n  apply( dat, 1, function(x) {\n    if( is.numeric(x) ) {\n      x <- round(x, 2)\n    }\n    paste( names( dat ), x, sep = \" = \", collapse = \"|||\" )\n  } )\n}\n\n#' Get Point Colors from Lattice Object\n#' \n#' Returns the colors used for points in a lattice plot object.\n#' \n#' @param plot the lattice plot object.\ngetPointColorsFromLatticeObject <- function( plot ) {\n  \n  panel.cols <- NULL\n  \n  kPanelArgs <- paste( capture.output( plot$call$panel ), collapse = \" \" )\n  kPanelArgs <- paste( kPanelArgs, collapse = \" \" )\n  \n  ## if kPanelArgs is NULL, try getting it directly from plot$panel\n  if( kPanelArgs == \"NULL\" ) {\n    kPanelArgs <- plot$panel\n  }\n  \n  kPanelArgs <- gsub( \" \", \"\", kPanelArgs )\n  \n  ## is this either an xyplot / dotplot, or are the panel.xyplot\n  ## or panel.dotplot panels used?\n  \n  pattern <- \"panel\\\\.xyplot|panel\\\\.dotplot\"\n  reg <- regexpr( pattern, kPanelArgs )\n  \n  if( reg > 0 ) {\n    tmp <- regmatches( kPanelArgs, reg )\n    \n    ## ugly parsing\n    \n    panel.cols <- regmatches( tmp, regexpr( \"col.*\", tmp) )\n    panel.cols <- gsub( \"col=\", \"\", panel.cols )\n    panel.cols <- gsub( 'c\\\\(\"', \"\", panel.cols )\n    panel.cols <- gsub( '\"', \"\", panel.cols )\n    panel.cols <- gsub( \")\", \"\", panel.cols )\n    panel.cols <- unlist( strsplit( panel.cols, \",\" ) )\n    \n    common.cols <- plot$panel.args.common$col\n    if( length( common.cols ) > 0 ) {\n      panel.cols <- c( panel.cols, common.cols )\n    }\n    \n    ## if any of the panel.cols are integers, they will be called from the\n    ## current lattice theme.\n    \n    for( i in seq_along(panel.cols) ) {\n      if( is.integer( panel.cols[i] ) ) {\n        panel.cols[i] <- trellis.par.get(\"superpose.symbol\")$col[i]\n      }\n    }\n  }\n  \n  ## what if we have boxplots?\n  \n  pattern <- \"panel\\\\.bwplot\"\n  reg <- regexpr( pattern, kPanelArgs )\n  \n  if( reg > 0 ) {\n    \n    panel.cols <- plot$call$par.settings$plot.symbol$col\n    \n    if( is.null( panel.cols ) ) {\n      panel.cols <- trellis.par.get()$dot.symbol$col\n    }\n    \n  }\n  \n  if( !is.null( plot$par.settings$plot.symbol$col ) ) {\n    panel.cols <- c( panel.cols, plot$par.settings$plot.symbol$col )\n  } else {\n    panel.cols <- c( panel.cols, trellis.par.get()$dot.symbol$col )\n  }\n  \n  if( !is.null( plot$panel.args.common$groups ) & is.null( plot$panel.args.common$col ) ) {\n    panel.cols <- c( panel.cols, \n                     trellis.par.get()$superpose.symbol$col[\n                       1:length( unique( plot$panel.args.common$groups ) )\n                       ] )\n  }\n  kCall <- capture.output( plot$call )\n  \n  if( is.null( panel.cols ) ) {\n    stop(\"ERROR: Could not detect plot colors for annotation!\")\n  }\n  \n  panel.cols <- unique( panel.cols )\n  \n  return( panel.cols )\n  \n}\n\n## Gets the colors used for points, then converts them to the same\n## format as expected in SVG attributes. Ie, converts from the\n## hex representation to a percentage-based XML attribute with\n## structure 'stroke:rgb(<color>)'.\n\n## Intended for lattice plots.\n\n#' Get and Convert Lattice Plot colors to RGB\n#' \n#' Gets the colors used for points in a lattice plot object, then\n#' converts them to the same format as expected in SVG attributes.\n#' @param plot the \\code{lattice} plot object.\nSVG.getLatticePointColors <- function(plot) {\n  \n  kCols <- getPointColorsFromLatticeObject( plot )\n  kCols <- col2rgb( kCols ) / 255 * 100\n  strList <- c()\n  \n  for( i in 1:ncol(kCols) ) {\n    \n    cCol <- kCols[,i]\n    cCol <- round( cCol, 6 )\n    \n    outString <- \"stroke:rgb(\"\n    outString <- paste0( outString,\n                         paste( cCol, collapse = \"%,\" )\n    )\n    outString <- paste0( outString, \"%);\" )\n    \n    strList <- c( strList, outString )\n    \n  }\n  \n  strList  \n  \n}\n\n\n## For some reason, after using the addPlotPoints function, SVG adds in\n## an unwanted fill style. Go back and remove it, and reset the original\n## fill style.\n\n#' Remove Fill Style\n#' \n#' For some reason, after using the \\code{addPlotPoints} function, SVG adds\n#' in an unwanted fill style. We remove it and reset the original fill style.\n#' @param plot the lattice plot object.\n#' @param allPoints the R object produced from an \\code{addPlotPoints} call.\nSVG.removeFillStyle <- function( plot, allPoints ) {\n  \n  counter <- 1\n  theCols <- SVG.getLatticePointColors(plot)\n  \n  for( i in 1:length(allPoints) ) {\n    cPanel <- allPoints[[i]]\n    for( j in 1:length(cPanel) ) {\n      cNode <- cPanel[[j]]\n      cAttr <- xmlGetAttr( cNode, \"style\" )\n      cAttr <- gsub( \" \", \"\", cAttr )\n      \n      theAttrs <- unlist( strsplit( cAttr, \";\" ) )\n      \n      ## Remove the fill attribute from the attrs\n      theAttrs <- theAttrs[ !(theAttrs %in% grep(\"fill:\", theAttrs, value=T)) ]\n      theAttrs <- paste( theAttrs, collapse = \";\" )\n      \n      ## Check the colors to determine whether or not\n      ## the point retrieved by getPlotPoints is actually a\n      ## point we wish to add a tool-tip to.\n      \n      isPoint <- rep(0, length(theCols) )\n      for( k in 1:length( theCols ) ) {\n        isPoint[k] <- length( grep( theCols[k], cAttr, fixed=T ) )\n      }\n      \n      (isPoint <- any( isPoint > 0 ))\n      \n      if( isPoint ) {\n        \n        removeAttributes( cNode, \"style\" )\n        addAttributes( cNode, \n                       style = theAttrs\n        )\n        \n      } \n    }\n  }\n  \n  invisible(counter)\n  \n}\n\n## The new implementation of SVG::getPlotPoints, which uses the\n## plot points collected by that SVG function, and filters it down\n## to the 'true' plot points as based on the colors of points used.\n\n## Function is intended to be used with lattice plots.\n\n#' Get Plot Points\n#' \n#' This function returns the 'true' plot points in an SVGAnnotation-generated\n#' \\code{doc}; ie, it discards any points that are eg. lines, smooths, and so\n#' forth.\n#' \n#' @param doc generated XML doc from \\code{svgPlot}.\n#' @param plot the \\code{lattice} plot object.\n#' @param allPoints output returned from a \\code{getPlotPoints} call.\nkGetPlotPoints <- function( doc, plot, allPoints ) {\n  \n  counter <- 1\n  theCols <- SVG.getLatticePointColors( plot )\n  \n  out <- c()\n  \n  for( i in 1:length(allPoints) ) {\n    cPanel <- allPoints[[i]]\n    for( j in 1:length(cPanel) ) {\n      cNode <- cPanel[[j]]\n      cAttr <- xmlGetAttr( cNode, \"style\" )\n      cAttr <- gsub( \" \", \"\", cAttr )\n      \n      theAttrs <- unlist( strsplit( cAttr, \";\" ) )\n      \n      ## Get the original fill\n      origFill <- grep( \"fill:\", theAttrs, value=T )\n      \n      ## Check the colors to determine whether or not\n      ## the point retrieved by getPlotPoints is actually a\n      ## point we wish to add a tool-tip to.\n      \n      isPoint <- rep(0, length(theCols) )\n      for( k in 1:length( theCols ) ) {\n        isPoint[k] <- length( grep( theCols[k], cAttr, fixed=T ) ) +\n          length( grep( gsub( \"stroke\", \"fill\", theCols[k] ), cAttr, fixed=T ) )\n      }\n      \n      (isPoint <- any( isPoint > 0 ))\n      \n      if( isPoint ) {\n        \n        xmlAttrs( cNode ) <- c(\n          id = paste0(\"true-plot-point-\", counter),\n          onmouseover=paste0(\"color_point(evt, \", counter, \", 'red')\"),\n          onmouseout=paste0(\"reset_color(evt, \", counter, \")\" ),\n          fill=gsub(\"fill:\", \"\", origFill),\n          originalFill=gsub(\"fill:\", \"\", origFill)\n        )\n        \n        out <- c(out, cNode)   \n        counter <- counter + 1\n        \n      } \n    }\n  }\n  \n  return( unlist( out ) )\n  \n}\n\n#' Make an SVG with Tool-Tip Annotations\n#' \n#' This function takes a lattice plot, plus the data frame it was generated\n#' from, and generates a tool-tip annotated lattice plot.\n#' @param plot the \\code{lattice} plot object.\n#' @param dat the \\code{data.frame} used in generating the lattice plot.\n#' @param outFile location to output the generated SVG file.\n#' @param cols the columns to use when generating the annotated SVG.\n#' @param width width, in inches, of the generated SVG plot.\n#' @param height, in inches, of the generated SVG plot.\n#' @export\nmakeSVG <- function( plot, dat, outFile = NULL, cols=NULL, width=4, height=4 ) {\n  \n  require(SVGAnnotation)\n  require(plyr)\n  \n  ## Get the variables from the plot formula\n  kVars <- all.vars( plot$formula )\n  if( !is.na( kVars[3] ) ) {\n    kPanelFactor <- kVars[3]\n  }\n  kGroupFactor <- kVars[2]\n  kY <- kVars[1]  \n  \n  ## Get the groups argument, if it exists.\n  getArgs <- function(plot) {\n    tmp <- capture.output( plot$call )\n    tmp <- gsub( \" \", \"\", tmp )\n    plotArgs <- unlist( strsplit( tmp, \",\" ) )\n    plotArgs <- gsub( \")\", \"\", plotArgs )\n    return( plotArgs )\n  }\n  \n  ## Rerrange the data frame so that the points plotted match up with\n  ## the generated tooltips\n  \n  if( !is.na( kVars[3] ) ) {\n    dat <- arrange( dat, get(kPanelFactor), get(kGroupFactor), -get(kY) )\n  } else {\n    dat <- arrange( dat, get(kGroupFactor), -get(kY) )\n  }  \n  \n  if( length( grep(\"groups=\", getArgs(plot)) ) > 0 ) {\n    tmp <- grep( \"groups=\", getArgs(plot), value=T )\n    tmp <- gsub(\"groups=\", \"\", tmp )\n    kGroupColorFactor <- tmp\n    if( !is.na( kVars[3] ) ) {\n      dat <- arrange(dat, get(kPanelFactor), get(kGroupColorFactor), get(kGroupFactor), -get(kY) )\n    } else {\n      dat <- arrange(dat, get(kGroupColorFactor), get(kGroupFactor), -get(kY) )\n    }    \n  }\n  \n  plot <- rearrangePanelXYPoints( plot )\n  \n  kTips <- SVG.getNames( dat, x = kGroupFactor, y = kY, cols=cols )\n  \n  doc <- svgPlot( plot, width=width, height=height, addInfo = FALSE )\n  \n  ## Set up number of panels\n  nPanels <- 1\n  \n  if( class( plot ) == \"trellis\" ) {\n    nPanels <- length( plot$panel.args )\n  }\n  \n  ## The Javascript functions are added 'as-is', embedded in the document,\n  ## in order to improve portability. Hence, any generated SVG can be\n  ## included in an HTML document with <embed ... />, and we do not need to\n  ## make sure the script files are hosted somewhere.\n  \n  addECMAScripts( doc, \n                  I(\"function color_point(evt, which, color) { path = document.getElementById(\\\"true-plot-point-\\\" + which); path.setAttribute(\\\"fill\\\", color); } function reset_color(evt, which) { path = document.getElementById(\\\"true-plot-point-\\\" + which); path.setAttribute(\\\"fill\\\", path.getAttribute(\\\"originalFill\\\")); }\"),\n                  insertJS = TRUE )\n  \n  addECMAScripts( doc, \n                  I(\"var MAX_TEXT_ELEMENTS = 20;\\nvar SVGDocument = null;\\nvar SVGRoot = null;\\nvar SVGViewBox = null;\\nvar toolTip = null;\\nvar TrueCoords = null;\\nvar tipBox = null;\\nvar tipText = null;\\nfor( j=1; j<=MAX_TEXT_ELEMENTS; j++ ) {\\n    eval( 'var text' + j + ' = null;');\\n}\\nvar kWidth = null;\\nvar kHeight = null;\\nvar lastElement = null;\\nfunction Init(evt)\\n{\\n    SVGDocument = evt.target.ownerDocument;\\n    SVGRoot = SVGDocument.documentElement;\\n    TrueCoords = SVGRoot.createSVGPoint();\\n    toolTip = SVGDocument.getElementById('ToolTip');\\n    tipBox = SVGDocument.getElementById('tipbox');\\n    tipText = SVGDocument.getElementById('tipText');\\n    \\n    for( j=1; j<=MAX_TEXT_ELEMENTS; j++ ) {\\n        eval( \\\"text\\\" + j + \\\" = SVGDocument.getElementById('text\\\" + j + \\\"');\\\" );\\n    }\\n    \\n    SVGRoot.addEventListener('mousemove', ShowTooltip, false);\\n    SVGRoot.addEventListener('mouseout', HideTooltip, false);\\n    \\n    toolTip.setAttributeNS(null, 'visibility', 'hidden');\\n    \\n    kWidth = SVGRoot.getAttribute('kWidth');\\n    kHeight = SVGRoot.getAttribute('kHeight');\\n};\\nfunction GetTrueCoords(evt)\\n{\\n    var newScale = SVGRoot.currentScale;\\n    var translation = SVGRoot.currentTranslate;\\n    TrueCoords.x = (evt.clientX - translation.x)/newScale;\\n    TrueCoords.y = (evt.clientY - translation.y)/newScale;\\n};\\nfunction HideTooltip( evt )\\n{\\n    toolTip.setAttributeNS(null, 'visibility', 'hidden');\\n};\\nfunction ShowTooltip( evt )\\n{\\n    GetTrueCoords( evt );\\n    var tipScale = 1/SVGRoot.currentScale;\\n    var textWidth = 0;\\n    var tspanWidth = 0;\\n    var boxHeight = 20;\\n    tipBox.setAttributeNS(null, 'transform', 'scale(' + tipScale + ',' + tipScale + ')' );\\n    tipText.setAttributeNS(null, 'transform', 'scale(' + tipScale + ',' + tipScale + ')' );\\n    \\n    var titleValue = '';\\n    var descValue = '';\\n    var targetElement = evt.target;\\n    if ( lastElement != targetElement )\\n    {\\n        \\n        var allText = targetElement.getElementsByTagName('desc').item(0);\\n        var textValue = allText.firstChild.nodeValue;\\n        textValue = textValue.split(\\\"|||\\\");\\n                      \\n        for( j=1; j<=MAX_TEXT_ELEMENTS; j++ ) {\\n             eval( \\\"text\\\" + j + \\\".setAttributeNS(null, 'display', 'none' )\\\" );\\n        }\\n        \\n        var testWidth = 0;\\n        \\n        for( i=0; i < textValue.length; i++ ) {\\n            tt = eval( 'text' + (i + 1) );\\n            tt.firstChild.nodeValue = textValue[i];\\n            tt.setAttributeNS(null, 'display', 'inline');\\n        }\\n        \\n        \\n    }\\n    var xPos = TrueCoords.x + (10 * tipScale);\\n    var yPos = TrueCoords.y + (10 * tipScale);\\n        \\n        \\n    if ( '' != textValue[0] & xPos < kWidth & yPos < kHeight )\\n    {   \\n        var outline = tipText.getBBox();\\n        tipBox.setAttributeNS(null, 'width', Number(outline.width) + 10 );\\n        tipBox.setAttributeNS(null, 'height', Number(outline.height) + 10 );\\n        \\n        if( xPos > kWidth/2 ) {\\n            xPos = xPos - Number(outline.width) - 25;\\n        }\\n        \\n        if( yPos > kHeight/2 ) {\\n            yPos = yPos - Number(outline.height) - 30;\\n        }\\n        toolTip.setAttributeNS(null, 'transform', 'translate(' + xPos + ',' + yPos + ')');\\n        toolTip.setAttributeNS(null, 'visibility', 'visible');\\n    }\\n};\"),\n                  insertJS = TRUE )\n  \n  ## Get the 'true' plot points\n  allPoints <- getPlotPoints( doc, FALSE )\n  kPoints <- kGetPlotPoints( doc, plot=plot, allPoints=allPoints )\n  \n  ## Find the outliers from the boxplot\n  \n  outlierPoints <- c()\n  if( !is.na( kVars[3] ) ) {\n    kpGroup <- paste( kPanelFactor, kGroupFactor, sep = \" : \" )\n    dat[[ kpGroup ]] <- \n      paste( dat[[kPanelFactor]], dat[[kGroupFactor]] )\n  } else {\n    kpGroup <- kGroupFactor\n  }\n  \n  if( workingWithBoxPlots( plot ) ) {\n    kCoef <- plot$panel.args.common$coef\n    if( is.null( plot$panel.args.common$coef ) ) {\n      kCoef <- 1.5\n    }\n    \n    kFiveNums <- vector(\"list\", length( unique( dat[[kpGroup]] ) ) )\n    names( kFiveNums ) <- unique( dat[[kpGroup]] )\n    for( i in 1:length( unique( dat[[kpGroup]] ) ) ) {\n      \n      tmp <- dat[ dat[[kpGroup]] == unique( dat[[kpGroup]] )[i], ]\n      kFiveNums[[i]] <- fivenum( tmp[[kY]] )\n      \n    }\n    \n    lower_limits <- lapply( kFiveNums, function(x) {\n      iqr = x[4] - x[2]\n      x[2] - kCoef * iqr        \n    } )\n    \n    upper_limits <- lapply( kFiveNums, function(x) {\n      iqr = x[4] - x[2]\n      x[4] + kCoef * iqr\n    })\n    \n    dat$isOutlier <- F\n    \n    for( i in 1:nrow(dat) ) {\n      cGroup <- dat[i,kpGroup]\n      if( dat[[kY]][i] < lower_limits[[cGroup]] | \n        dat[[kY]][i] > upper_limits[[cGroup]] ) {\n        dat$isOutlier[i] <- T\n      }\n    }\n    \n    kTips <- kTips[ dat$isOutlier ]\n    \n  }\n  \n  if( length( kTips ) > 0 ) {\n    \n    addToolTips(doc, \n                text = kTips,\n                paths = kPoints,\n                addArea = TRUE,\n                elName = \"desc\",\n                addTitleAttribute = FALSE,\n                addCSS = F\n    )\n    \n  }\n  \n  ## Remove the unwanted fill style that has been added\n  SVG.removeFillStyle( plot, allPoints )\n  \n  ## post-processing of the XML document\n  \n  dd <- xmlRoot( doc )\n  removeAttributes( dd, \"originalSource\" )\n  \n  ## Remove the original height+width attributes, and reset them\n  kWidth <- gsub( \"[a-z]\", \"\", xmlGetAttr( dd, \"width\" ) )\n  kHeight <- gsub( \"[a-z]\", \"\", xmlGetAttr( dd, \"height\" ) )\n  \n  dd <- removeAttributes( dd )\n  dd <- addAttributes( dd,\n                       \"onload\" = \"Init(evt)\",\n                       \"kWidth\" = kWidth,\n                       \"kHeight\" = kHeight\n  )\n  \n  ddd <- xmlRoot( dd, skip=FALSE )\n  removeAttributes( ddd, \"originalSource\" )\n  tmp <- capture.output( print( ddd ) )\n  \n  ## Remove </svg> (final line)\n  tmp <- tmp[1:(length(tmp)-1)]\n  \n  theNode <- c(\"<g id='ToolTip' opacity='1' visibility='hidden' pointer-events='none'>\n  <rect id='tipbox' x='0' y='5' width='88' height='20' rx='2' ry='2' fill='white' stroke='black'/>\n               <text id='tipText' x='5' y='20' font-family='Arial' font-size='12'>\n               <tspan id='text1' x='5' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text2' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text3' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text4' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text5' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text6' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text7' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text8' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text9' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text10' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text11' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text12' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text13' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text14' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text15' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text16' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text17' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text18' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text19' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               <tspan id='text20' x='5' dy='15' font-weight='bold'><![CDATA[]]></tspan>\n               </text>\n               </g>\")\n  \n  theNode <- unlist( strsplit( theNode, \"\\n\" ) )\n  tmp <- c( tmp, theNode )\n  tmp <- c( tmp, \"</svg>\" )\n  \n  if( !is.null( outFile ) ) {\n    cat( tmp, file = outFile, sep=\"\\n\" )\n  } else {\n    cat( \"<div>\", tmp, \"</div>\", sep=\"\\n\" )\n  }\n  \n}\n\n## Debugging\n# library( ggplot2 )\n# \n# dat <- data.frame(\n#   x=1:10,\n#   y=rnorm(10),\n#   g=as.factor(rep(1:2,each=5)),\n#   gg=as.factor(rep(1:2,times=5))\n#   )\n# \n# plot <- ggplot( dat, aes(x=x, y=y) ) +\n#   geom_point( colour=\"#010101\" )\n# dat <- dat\n\n# makeSVG.ggplot <- function( \n#   plot, \n#   dat = plot$data, \n#   outFile = NULL, \n#   cols=NULL, \n#   width=4, \n#   height=4 \n#   ) {\n#   \n#   ## Rearrange the data depending on the function call\n#   ## plot$data <- arrange( plot$data, <figure this out later> )\n#   SVG.getNames( dat, \"x\", \"y\" )\n#   \n#   ## Future - can we avoid using a temporary file?\n#   kTempFile <- tempfile( fileext = \".svg\" )\n#   \n#   svg( kTempFile, width=width, height=height )\n#   print( plot )\n#   dev.off()\n#   \n#   dd <- xmlParse( kTempFile )\n#   ddd <- xmlRoot( dd )\n#   \n#   allPoints <- getPlotPoints( dd, FALSE )\n#   kPoints <- gg_GetPlotPoints( dd, plot, allPoints )\n#   \n# }\n#   \n# setMethod( \"makeSVG\", \"ggplot\", makeSVG.ggplot )\n\n",
    "created" : 1355791998657.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3963618702",
    "id" : "2AD68FA3",
    "lastKnownWriteTime" : 1355792014,
    "path" : "~/Dropbox/R/kPackages/EasySVGAnnotation/EasySVGAnnotation/R/EasySVGAnnotation.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}